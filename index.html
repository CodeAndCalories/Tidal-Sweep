<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tidal Sweep</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Lilita+One&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --cell-size: 36px;
    --transition-speed: 0.6s;
  }

  /* ===== SHALLOWS ===== */
  body.theme-easy {
    --bg: #1a3a4a;
    --surface: #1e4252;
    --border: #2e6070;
    --text: #a0d0d8;
    --accent: #2ec4a8;
    --accent-dim: #1a9880;
    --danger: #e05080;
    --warn: #d8a030;
    --cell-bg: #1c4858;
    --cell-hover: #245868;
    --cell-revealed: #16323e;
    --title-from: #2ec4a8;
    --title-to: #48b0d8;
    --overlay-bg: rgba(22, 50, 62, 0.88);
    --footer-color: #5a9098;
    --depth-color: #4a7880;
    --bubble-color: rgba(180, 230, 240, 0.12);
    --bubble-border: rgba(180, 230, 240, 0.1);
    --shadow-glow: rgba(40, 180, 170, 0.08);
    --sand-bar: rgba(0, 0, 0, 0.15);
    --wave1: rgba(80, 180, 200, 0.06);
    --wave2: rgba(60, 160, 180, 0.04);
    --wave3: rgba(100, 200, 210, 0.05);
  }

  /* ===== DEEP SEA ===== */
  body.theme-medium {
    --bg: #061a2e;
    --surface: #0a2440;
    --border: #184060;
    --text: #90c0e0;
    --accent: #00d4b8;
    --accent-dim: #009080;
    --danger: #e84488;
    --warn: #e8a020;
    --cell-bg: #0e2e50;
    --cell-hover: #143a60;
    --cell-revealed: #081c32;
    --title-from: #00d4b8;
    --title-to: #3090e0;
    --overlay-bg: rgba(6, 26, 46, 0.88);
    --footer-color: #2a5878;
    --depth-color: #1e4060;
    --bubble-color: rgba(120, 200, 255, 0.1);
    --bubble-border: rgba(100, 180, 255, 0.06);
    --shadow-glow: rgba(0, 100, 200, 0.1);
    --sand-bar: rgba(0, 0, 0, 0.25);
    --wave1: rgba(30, 100, 180, 0.05);
    --wave2: rgba(20, 80, 150, 0.04);
    --wave3: rgba(40, 120, 200, 0.03);
  }

  /* ===== THE ABYSS ===== */
  body.theme-hard {
    --bg: #020810;
    --surface: #040e1a;
    --border: #0e2038;
    --text: #5080a8;
    --accent: #00a8c0;
    --accent-dim: #006878;
    --danger: #c03068;
    --warn: #b88018;
    --cell-bg: #061428;
    --cell-hover: #0a1e38;
    --cell-revealed: #030a14;
    --title-from: #00a8c0;
    --title-to: #1860a0;
    --overlay-bg: rgba(2, 8, 16, 0.92);
    --footer-color: #152840;
    --depth-color: #0e1828;
    --bubble-color: rgba(60, 120, 180, 0.05);
    --bubble-border: rgba(60, 120, 180, 0.03);
    --shadow-glow: rgba(0, 60, 120, 0.08);
    --sand-bar: rgba(0, 0, 0, 0.4);
    --wave1: rgba(10, 40, 80, 0.04);
    --wave2: rgba(8, 30, 60, 0.03);
    --wave3: rgba(12, 50, 90, 0.02);
  }

  body {
    color: var(--text);
    font-family: 'Fredoka', sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    overflow: hidden;
    position: relative;
    background: var(--bg);
    transition:
      background var(--transition-speed) ease,
      color var(--transition-speed) ease;
  }

  /* === WAVES === */
  .waves {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 1;
    overflow: hidden;
  }

  .wave {
    position: absolute;
    width: 300%;
    height: 100%;
    top: 0;
    left: -100%;
  }

  .wave-1 {
    background: repeating-linear-gradient(90deg, transparent 0%, var(--wave1) 12%, transparent 24%);
    animation: waveDrift1 18s ease-in-out infinite;
  }
  .wave-2 {
    background: repeating-linear-gradient(88deg, transparent 0%, var(--wave2) 15%, transparent 30%);
    animation: waveDrift2 24s ease-in-out infinite;
  }
  .wave-3 {
    background: repeating-linear-gradient(92deg, transparent 0%, var(--wave3) 10%, transparent 20%);
    animation: waveDrift3 14s ease-in-out infinite;
  }

  @keyframes waveDrift1 {
    0%, 100% { transform: translateX(0%) translateY(0); }
    50% { transform: translateX(15%) translateY(8px); }
  }
  @keyframes waveDrift2 {
    0%, 100% { transform: translateX(0%) translateY(0); }
    50% { transform: translateX(-10%) translateY(-6px); }
  }
  @keyframes waveDrift3 {
    0%, 100% { transform: translateX(0%) translateY(0); }
    50% { transform: translateX(8%) translateY(5px); }
  }

  /* === BUBBLES === */
  .bubbles {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 2;
    overflow: hidden;
  }

  .bubble {
    position: absolute;
    bottom: -20px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, var(--bubble-color), transparent);
    border: 1px solid var(--bubble-border);
    animation: bubbleRise linear infinite;
    transition: background var(--transition-speed) ease, border-color var(--transition-speed) ease;
  }

  @keyframes bubbleRise {
    0% { transform: translateY(0) translateX(0) scale(1); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 0.6; }
    100% { transform: translateY(-110vh) translateX(40px) scale(0.6); opacity: 0; }
  }

  /* === CREATURES === */
  .creatures {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 3;
    overflow: hidden;
  }

  .creature {
    position: absolute;
    opacity: 0;
    will-change: transform;
  }

  /* Fish (Shallows) */
  .fish {
    font-size: 0;
    filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
  }

  .fish-body {
    position: relative;
    display: inline-block;
  }

  .fish-body svg {
    display: block;
  }

  /* Shark (Deep Sea) */
  .shark {
    font-size: 0;
    filter: drop-shadow(0 4px 16px rgba(0, 0, 0, 0.4));
  }

  /* Kraken tentacle (Abyss) */
  .tentacle {
    filter: drop-shadow(0 0 20px rgba(120, 0, 60, 0.3));
  }

  /* Swim animations */
  @keyframes swimRight {
    0% { transform: translateX(-150px) translateY(0px); opacity: 0; }
    5% { opacity: 1; }
    50% { transform: translateX(50vw) translateY(-20px); opacity: 1; }
    95% { opacity: 1; }
    100% { transform: translateX(calc(100vw + 150px)) translateY(10px); opacity: 0; }
  }

  @keyframes swimLeft {
    0% { transform: translateX(calc(100vw + 150px)) translateY(0px); opacity: 0; }
    5% { opacity: 1; }
    50% { transform: translateX(50vw) translateY(15px); opacity: 1; }
    95% { opacity: 1; }
    100% { transform: translateX(-150px) translateY(-10px); opacity: 0; }
  }

  @keyframes tentacleRise {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
    10% { opacity: 0.6; }
    40% { transform: translateY(20vh) rotate(-8deg); opacity: 0.7; }
    60% { transform: translateY(15vh) rotate(5deg); opacity: 0.6; }
    90% { opacity: 0.3; }
    100% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
  }

  @keyframes fishWiggle {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(2deg); }
    75% { transform: rotate(-2deg); }
  }

  @keyframes tailSwish {
    0%, 100% { transform: scaleX(1); }
    50% { transform: scaleX(0.85); }
  }

  .game-container {
    position: relative;
    z-index: 10;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px;
    box-shadow:
      0 0 60px var(--shadow-glow),
      inset 0 1px 0 rgba(255, 255, 255, 0.04);
    max-width: 95vw;
    transition:
      background var(--transition-speed) ease,
      border-color var(--transition-speed) ease,
      box-shadow var(--transition-speed) ease;
  }

  .header { text-align: center; margin-bottom: 20px; }

  .title {
    font-family: 'Lilita One', cursive;
    font-size: 34px;
    background: linear-gradient(135deg, var(--title-from), var(--title-to), var(--title-from));
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: shimmer 4s ease-in-out infinite;
    letter-spacing: 3px;
    margin-bottom: 2px;
  }

  @keyframes shimmer {
    0%, 100% { background-position: 0% center; }
    50% { background-position: 200% center; }
  }

  .subtitle {
    font-size: 11px;
    color: var(--footer-color);
    letter-spacing: 4px;
    text-transform: uppercase;
    font-weight: 500;
    transition: color var(--transition-speed) ease;
  }

  .difficulty-bar {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-bottom: 16px;
  }

  .diff-btn {
    background: var(--cell-bg);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Fredoka', sans-serif;
    font-size: 12px;
    font-weight: 600;
    padding: 8px 18px;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.25s;
    letter-spacing: 1px;
  }

  .diff-btn:hover { border-color: var(--accent-dim); }

  .diff-btn.active {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(0, 200, 180, 0.08);
    box-shadow: 0 0 16px rgba(0, 200, 180, 0.12);
  }

  .diff-label { font-size: 13px; }
  .diff-info { font-size: 9px; opacity: 0.5; display: block; margin-top: 2px; }

  .status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding: 10px 16px;
    background: var(--sand-bar);
    border-radius: 12px;
    border: 1px solid var(--border);
    transition: background var(--transition-speed) ease, border-color var(--transition-speed) ease;
  }

  .stat {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 15px;
    font-weight: 700;
  }

  .stat-icon { font-size: 18px; }
  .jelly-count { color: var(--danger); transition: color var(--transition-speed) ease; }
  .timer-count { color: var(--warn); transition: color var(--transition-speed) ease; }

  .reset-btn {
    background: rgba(0, 200, 180, 0.08);
    border: 1px solid var(--border);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.25s;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .reset-btn:hover {
    border-color: var(--accent);
    box-shadow: 0 0 14px rgba(0, 200, 180, 0.2);
    transform: rotate(180deg);
  }

  .grid-wrapper { display: flex; justify-content: center; }

  .grid {
    display: inline-grid;
    gap: 2px;
    background: var(--sand-bar);
    padding: 6px;
    border-radius: 12px;
    border: 1px solid var(--border);
    transition: background var(--transition-speed) ease, border-color var(--transition-speed) ease;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    background: var(--cell-bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    font-weight: 700;
    font-family: 'Fredoka', sans-serif;
    transition: background 0.15s ease, border-color 0.15s ease;
    user-select: none;
    -webkit-user-select: none;
    position: relative;
  }

  .cell:hover:not(.revealed):not(.game-over-cell) {
    background: var(--cell-hover);
    border-color: rgba(0, 200, 180, 0.3);
    box-shadow: 0 0 8px rgba(0, 200, 180, 0.08);
  }

  .cell.revealed {
    background: var(--cell-revealed);
    border-color: rgba(255, 255, 255, 0.03);
    cursor: default;
  }

  .cell.revealed.empty { background: var(--cell-revealed); }

  .cell.flagged::after {
    content: 'ðŸš©';
    font-size: 16px;
    animation: flagDrop 0.25s ease-out;
  }

  @keyframes flagDrop {
    0% { transform: translateY(-8px); opacity: 0; }
    100% { transform: translateY(0); opacity: 1; }
  }

  .cell.jelly-hit {
    background: rgba(232, 68, 136, 0.25) !important;
    border-color: var(--danger) !important;
    animation: jellyZap 0.4s ease-out;
  }

  @keyframes jellyZap {
    0% { transform: scale(1); }
    25% { transform: scale(1.15); }
    50% { transform: scale(0.95); }
    100% { transform: scale(1); }
  }

  .cell.jelly-shown { background: rgba(232, 68, 136, 0.08); }

  .cell .jelly-icon {
    font-size: 17px;
    filter: drop-shadow(0 0 4px rgba(232, 68, 136, 0.4));
  }

  /* Number colors per theme */
  body.theme-easy .cell.n1 { color: #38a8cc; }
  body.theme-easy .cell.n2 { color: #20b890; }
  body.theme-easy .cell.n3 { color: #d05070; }
  body.theme-easy .cell.n4 { color: #8860cc; }
  body.theme-easy .cell.n5 { color: #cc7030; }
  body.theme-easy .cell.n6 { color: #30b890; }
  body.theme-easy .cell.n7 { color: #a070cc; }
  body.theme-easy .cell.n8 { color: #6890a0; }

  body.theme-medium .cell.n1 { color: #44bbff; }
  body.theme-medium .cell.n2 { color: #00e4c8; }
  body.theme-medium .cell.n3 { color: #e84488; }
  body.theme-medium .cell.n4 { color: #9966ee; }
  body.theme-medium .cell.n5 { color: #f07030; }
  body.theme-medium .cell.n6 { color: #44ddaa; }
  body.theme-medium .cell.n7 { color: #cc88ff; }
  body.theme-medium .cell.n8 { color: #607890; }

  body.theme-hard .cell.n1 { color: #2878b8; }
  body.theme-hard .cell.n2 { color: #009888; }
  body.theme-hard .cell.n3 { color: #b03060; }
  body.theme-hard .cell.n4 { color: #6644aa; }
  body.theme-hard .cell.n5 { color: #a05820; }
  body.theme-hard .cell.n6 { color: #208868; }
  body.theme-hard .cell.n7 { color: #8860aa; }
  body.theme-hard .cell.n8 { color: #384858; }

  /* OVERLAY */
  .overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: var(--overlay-bg);
    backdrop-filter: blur(6px);
    z-index: 50;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.3s ease;
    transition: background var(--transition-speed) ease;
  }

  .overlay.show { display: flex; }

  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  .overlay-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 40px 52px;
    text-align: center;
    box-shadow: 0 0 80px var(--shadow-glow), 0 0 30px rgba(0, 0, 0, 0.5);
    animation: surfaceUp 0.4s ease;
    transition: background var(--transition-speed) ease, border-color var(--transition-speed) ease;
  }

  @keyframes surfaceUp {
    from { transform: translateY(30px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  .overlay-icon { font-size: 52px; margin-bottom: 12px; }

  .overlay-title {
    font-family: 'Lilita One', cursive;
    font-size: 24px;
    margin-bottom: 8px;
    letter-spacing: 2px;
  }

  .overlay-title.win { color: var(--accent); text-shadow: 0 0 24px rgba(0, 200, 180, 0.35); }
  .overlay-title.lose { color: var(--danger); text-shadow: 0 0 24px rgba(232, 68, 136, 0.35); }

  .overlay-stats {
    font-size: 13px;
    color: var(--footer-color);
    margin-bottom: 24px;
    transition: color var(--transition-speed) ease;
  }

  .overlay-btn {
    background: linear-gradient(135deg, var(--accent), var(--title-to));
    color: #fff;
    border: none;
    font-family: 'Lilita One', cursive;
    font-size: 15px;
    padding: 12px 32px;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.25s;
    letter-spacing: 2px;
    box-shadow: 0 4px 20px var(--shadow-glow);
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }

  .overlay-btn:hover {
    box-shadow: 0 4px 30px var(--shadow-glow);
    transform: translateY(-2px);
  }

  .footer {
    margin-top: 14px;
    text-align: center;
    font-size: 11px;
    color: var(--footer-color);
    letter-spacing: 1px;
    transition: color var(--transition-speed) ease;
  }

  .footer span { color: var(--accent-dim); }

  .depth-label {
    display: inline-block;
    margin-top: 6px;
    font-size: 9px;
    color: var(--depth-color);
    letter-spacing: 3px;
    text-transform: uppercase;
    transition: color var(--transition-speed) ease;
  }

  @media (max-width: 600px) {
    :root { --cell-size: 30px; }
    .game-container { padding: 14px; }
    .title { font-size: 26px; }
    .diff-btn { padding: 6px 12px; font-size: 11px; }
    .overlay-box { padding: 28px 24px; }
  }
</style>
</head>
<body class="theme-easy">

<div class="waves">
  <div class="wave wave-1"></div>
  <div class="wave wave-2"></div>
  <div class="wave wave-3"></div>
</div>

<div class="bubbles" id="bubbles"></div>
<div class="creatures" id="creatures"></div>

<div class="game-container">
  <div class="header">
    <div class="title">TIDAL SWEEP</div>
    <div class="subtitle" id="subtitleText">navigate the shallows</div>
  </div>

  <div class="difficulty-bar">
    <button class="diff-btn active" data-diff="easy">
      <span class="diff-label">Shallows</span>
      <span class="diff-info">9Ã—9 Â· 10 jelly</span>
    </button>
    <button class="diff-btn" data-diff="medium">
      <span class="diff-label">Deep Sea</span>
      <span class="diff-info">16Ã—16 Â· 40 jelly</span>
    </button>
    <button class="diff-btn" data-diff="hard">
      <span class="diff-label">The Abyss</span>
      <span class="diff-info">16Ã—30 Â· 99 jelly</span>
    </button>
  </div>

  <div class="status-bar">
    <div class="stat jelly-count">
      <span class="stat-icon">ðŸª¼</span>
      <span id="mineDisplay">10</span>
    </div>
    <button class="reset-btn" id="resetBtn" title="New Dive">ðŸŒŠ</button>
    <div class="stat timer-count">
      <span class="stat-icon">ðŸ«§</span>
      <span id="timerDisplay">000</span>
    </div>
  </div>

  <div class="grid-wrapper">
    <div class="grid" id="grid"></div>
  </div>

  <div class="footer">
    left click â€” reveal &nbsp;|&nbsp; right click â€” <span>flag</span>
    <div class="depth-label" id="depthLabel">depth: shoreline</div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="overlay-box">
    <div class="overlay-icon" id="overlayIcon"></div>
    <div class="overlay-title" id="overlayTitle"></div>
    <div class="overlay-stats" id="overlayStats"></div>
    <button class="overlay-btn" id="overlayBtn">DIVE AGAIN</button>
  </div>
</div>

<script>
// === BUBBLES ===
const bubblesEl = document.getElementById('bubbles');
for (let i = 0; i < 20; i++) {
  const b = document.createElement('div');
  b.className = 'bubble';
  const size = 4 + Math.random() * 16;
  b.style.width = size + 'px';
  b.style.height = size + 'px';
  b.style.left = Math.random() * 100 + '%';
  b.style.animationDuration = (8 + Math.random() * 14) + 's';
  b.style.animationDelay = (Math.random() * 10) + 's';
  bubblesEl.appendChild(b);
}

// === CREATURES ===
const creaturesEl = document.getElementById('creatures');
let creatureInterval = null;

function createFishSVG() {
  // Colorful tropical fish
  const colors = [
    ['#FFB347','#FF6B35'],
    ['#4ECDC4','#2AB7A9'],
    ['#FF6B8A','#EE4466'],
    ['#95E1D3','#5CC8B0'],
    ['#F8E16C','#E8C84A'],
    ['#A8D8EA','#6BB5D0'],
  ];
  const [body, fin] = colors[Math.floor(Math.random() * colors.length)];
  const size = 30 + Math.random() * 25;
  const w = size * 1.8;
  const h = size;

  const svg = `<svg width="${w}" height="${h}" viewBox="0 0 54 30" xmlns="http://www.w3.org/2000/svg">
    <g>
      <!-- Tail -->
      <path d="M4 15 L0 5 L10 15 L0 25 Z" fill="${fin}" opacity="0.8"/>
      <!-- Body -->
      <ellipse cx="28" cy="15" rx="18" ry="12" fill="${body}"/>
      <!-- Stripe -->
      <ellipse cx="28" cy="15" rx="18" ry="12" fill="none" stroke="rgba(255,255,255,0.25)" stroke-width="1.5"/>
      <path d="M24 4 Q26 15 24 26" stroke="rgba(255,255,255,0.3)" stroke-width="1.5" fill="none"/>
      <!-- Dorsal fin -->
      <path d="M22 4 Q28 -2 34 4" fill="${fin}" opacity="0.7"/>
      <!-- Eye -->
      <circle cx="36" cy="12" r="3" fill="white"/>
      <circle cx="37" cy="11.5" r="1.5" fill="#222"/>
      <!-- Mouth -->
      <path d="M44 15 Q46 16 44 17" stroke="#333" stroke-width="0.8" fill="none"/>
    </g>
  </svg>`;
  return { svg, w, h };
}

function createSharkSVG() {
   const size = 80 + Math.random() * 40;
  const w = size * 2;
  const h = size;

  const svg = `<svg width="${w}" height="${h}" viewBox="0 0 120 50" xmlns="http://www.w3.org/2000/svg">
    <g>
      <!-- Tail -->
      <path d="M8 25 L0 8 L16 22 Z" fill="#3a5068" opacity="0.9"/>
      <path d="M8 25 L2 40 L16 28 Z" fill="#3a5068" opacity="0.7"/>
      <!-- Body -->
      <ellipse cx="60" cy="26" rx="46" ry="16" fill="#4a6880"/>
      <!-- Belly -->
      <ellipse cx="60" cy="32" rx="38" ry="9" fill="#6888a0" opacity="0.5"/>
      <!-- Dorsal fin -->
      <path d="M50 10 L58 -4 L64 10" fill="#3a5068"/>
      <!-- Pectoral fins -->
      <path d="M70 38 L82 48 L78 36" fill="#3a5068" opacity="0.8"/>
      <path d="M45 38 L38 46 L48 37" fill="#3a5068" opacity="0.6"/>
      <!-- Eye -->
      <circle cx="88" cy="22" r="3.5" fill="#1a2a38"/>
      <circle cx="89" cy="21.5" r="1.2" fill="#4a8aaa"/>
      <!-- Gills -->
      <line x1="78" y1="20" x2="78" y2="30" stroke="#3a5068" stroke-width="1" opacity="0.6"/>
      <line x1="82" y1="20" x2="82" y2="29" stroke="#3a5068" stroke-width="1" opacity="0.5"/>
      <line x1="86" y1="21" x2="86" y2="28" stroke="#3a5068" stroke-width="1" opacity="0.4"/>
      <!-- Mouth -->
      <path d="M98 28 Q106 30 100 33" stroke="#2a3a48" stroke-width="1.2" fill="none"/>
      <!-- Teeth hint -->
      <path d="M99 29 L100 31 L101 29 L102 31 L103 29" stroke="rgba(255,255,255,0.3)" stroke-width="0.6" fill="none"/>
    </g>
  </svg>`;
  return { svg, w, h };
}
 
function createTentacleSVG() {
  const w = 100 + Math.random() * 40;
  const h = 420;
  const hue = 280 + Math.random() * 50; // 280-330 purple-magenta range
  const uid = 'tent' + Math.random().toString(36).slice(2, 8);

  // Generate center spine points with organic sway
  const midX = w / 2;
  const segments = 16;
  const spine = [];
  for (let i = 0; i <= segments; i++) {
    const t = i / segments; // 0 at base, 1 at tip
    const y = h - t * h;
    const sway = Math.sin(i * 0.6 + Math.random() * 0.3) * (12 + Math.random() * 14) * (0.4 + t * 0.6);
    spine.push({ x: midX + sway, y });
  }

  // Build tapered outline: right side up, then left side down
  const baseWidth = w * 0.38;
  const rightPts = [];
  const leftPts = [];
  for (let i = 0; i < spine.length; i++) {
    const t = i / (spine.length - 1);
    // Taper: wide at base, narrows to a point; slight bulge near base
    const taper = (1 - t * t) * (1 + 0.15 * Math.sin(t * Math.PI));
    const halfW = baseWidth * 0.5 * taper;
    // Perpendicular offset (approximate â€” just use horizontal offset for organic look)
    const wobble = Math.sin(i * 1.2) * 2;
    rightPts.push({ x: spine[i].x + halfW + wobble, y: spine[i].y });
    leftPts.push({ x: spine[i].x - halfW - wobble, y: spine[i].y });
  }

  // Smooth path from points using quadratic curves
  function smoothPath(pts) {
    let d = `M${pts[0].x.toFixed(1)} ${pts[0].y.toFixed(1)}`;
    for (let i = 1; i < pts.length - 1; i++) {
      const cx = (pts[i].x + pts[i + 1].x) / 2;
      const cy = (pts[i].y + pts[i + 1].y) / 2;
      d += ` Q${pts[i].x.toFixed(1)} ${pts[i].y.toFixed(1)} ${cx.toFixed(1)} ${cy.toFixed(1)}`;
    }
    const last = pts[pts.length - 1];
    d += ` L${last.x.toFixed(1)} ${last.y.toFixed(1)}`;
    return d;
  }

  // Combine into closed shape: right side up, connect at tip, left side down
  const tip = spine[spine.length - 1];
  const rightPath = smoothPath(rightPts);
  const leftReversed = [...leftPts].reverse();
  const leftPath = smoothPath(leftReversed);
  const outline = rightPath + ` L${tip.x.toFixed(1)} ${tip.y.toFixed(1)} ` +
    leftPath.replace(/^M[^ ]+ [^ ]+/, '') + ' Z';

  // Inner highlight spine path
  let spinePath = `M${spine[0].x.toFixed(1)} ${spine[0].y.toFixed(1)}`;
  for (let i = 1; i < spine.length - 1; i++) {
    const cx = (spine[i].x + spine[i + 1].x) / 2;
    const cy = (spine[i].y + spine[i + 1].y) / 2;
    spinePath += ` Q${spine[i].x.toFixed(1)} ${spine[i].y.toFixed(1)} ${cx.toFixed(1)} ${cy.toFixed(1)}`;
  }
  spinePath += ` L${tip.x.toFixed(1)} ${tip.y.toFixed(1)}`;

  // Suckers along the inner curve
  const suckerCount = 12;
  const suckers = [];
  for (let i = 1; i <= suckerCount; i++) {
    const t = i / (suckerCount + 1);
    const idx = Math.floor(t * (spine.length - 1));
    const frac = t * (spine.length - 1) - idx;
    const sp = spine[Math.min(idx, spine.length - 1)];
    const spNext = spine[Math.min(idx + 1, spine.length - 1)];
    const sx = sp.x + (spNext.x - sp.x) * frac;
    const sy = sp.y + (spNext.y - sp.y) * frac;
    const taper = (1 - t * t);
    const radius = (2.5 + taper * 5) * (0.8 + Math.random() * 0.4);
    const offsetX = taper * baseWidth * 0.18 * (Math.random() > 0.5 ? 1 : -1);
    suckers.push({ x: sx + offsetX, y: sy, r: radius, t });
  }

  // Bioluminescent glow spots
  const glows = [];
  for (let i = 0; i < 6; i++) {
    const t = (i + 1) / 8;
    const idx = Math.floor(t * (spine.length - 1));
    const sp = spine[Math.min(idx, spine.length - 1)];
    const taper = 1 - t * t;
    glows.push({
      x: sp.x + (Math.random() - 0.5) * baseWidth * taper * 0.3,
      y: sp.y,
      r: 1.5 + Math.random() * 2,
      dur: (2 + Math.random() * 3).toFixed(1)
    });
  }

  const svg = `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="${uid}g" x1="0" y1="1" x2="0" y2="0">
        <stop offset="0%" stop-color="hsla(${hue}, 50%, 12%, 0.9)"/>
        <stop offset="40%" stop-color="hsla(${hue}, 45%, 20%, 0.85)"/>
        <stop offset="100%" stop-color="hsla(${hue}, 35%, 28%, 0.5)"/>
      </linearGradient>
      <radialGradient id="${uid}h" cx="0.35" cy="0.5" r="0.65">
        <stop offset="0%" stop-color="hsla(${hue - 20}, 30%, 45%, 0.15)"/>
        <stop offset="100%" stop-color="transparent"/>
      </radialGradient>
      <filter id="${uid}f" x="-20%" y="-5%" width="140%" height="110%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="2"/>
      </filter>
    </defs>
    <!-- Soft shadow -->
    <path d="${outline}" fill="hsla(${hue}, 40%, 8%, 0.4)" filter="url(#${uid}f)" transform="translate(3, 3)"/>
    <!-- Main tentacle body -->
    <path d="${outline}" fill="url(#${uid}g)"/>
    <!-- Inner highlight/sheen -->
    <path d="${outline}" fill="url(#${uid}h)"/>
    <!-- Ridged texture lines -->
    ${Array.from({length: 10}, (_, i) => {
      const t = (i + 1) / 12;
      const idx = Math.floor(t * (spine.length - 1));
      const sp = spine[Math.min(idx, spine.length - 1)];
      const taper = (1 - t * t) * baseWidth * 0.42;
      return `<line x1="${(sp.x - taper).toFixed(1)}" y1="${sp.y.toFixed(1)}" x2="${(sp.x + taper).toFixed(1)}" y2="${sp.y.toFixed(1)}" stroke="hsla(${hue}, 25%, 18%, 0.2)" stroke-width="0.8"/>`;
    }).join('\n    ')}
    <!-- Suckers -->
    ${suckers.map(s => `
      <ellipse cx="${s.x.toFixed(1)}" cy="${s.y.toFixed(1)}" rx="${(s.r * 1.1).toFixed(1)}" ry="${(s.r * 0.8).toFixed(1)}" fill="hsla(${hue}, 25%, 15%, 0.5)" stroke="hsla(${hue}, 30%, 25%, 0.3)" stroke-width="0.5"/>
      <ellipse cx="${s.x.toFixed(1)}" cy="${s.y.toFixed(1)}" rx="${(s.r * 0.6).toFixed(1)}" ry="${(s.r * 0.4).toFixed(1)}" fill="hsla(${hue + 10}, 35%, 30%, 0.35)"/>
    `).join('')}
    <!-- Spine highlight -->
    <path d="${spinePath}" stroke="hsla(${hue - 10}, 25%, 40%, 0.1)" stroke-width="2" fill="none" stroke-linecap="round"/>
    <!-- Bioluminescent glow spots -->
    ${glows.map(g => `
      <circle cx="${g.x.toFixed(1)}" cy="${g.y.toFixed(1)}" r="${g.r.toFixed(1)}" fill="rgba(140, 180, 255, 0.35)">
        <animate attributeName="opacity" values="0.15;0.5;0.15" dur="${g.dur}s" repeatCount="indefinite"/>
      </circle>
      <circle cx="${g.x.toFixed(1)}" cy="${g.y.toFixed(1)}" r="${(g.r * 2.5).toFixed(1)}" fill="rgba(140, 180, 255, 0.08)">
        <animate attributeName="opacity" values="0.05;0.15;0.05" dur="${g.dur}s" repeatCount="indefinite"/>
      </circle>
    `).join('')}
  </svg>`;
  return { svg, w, h };
}

function spawnCreature(diff) {
  const el = document.createElement('div');
  el.className = 'creature';

  if (diff === 'easy') {
    // Tropical fish swimming left or right
    const { svg, w, h } = createFishSVG();
    const goRight = Math.random() > 0.5;
    el.classList.add('fish');
    el.innerHTML = `<div class="fish-body" style="${goRight ? '' : 'transform: scaleX(-1);'}">${svg}</div>`;
    el.style.top = (15 + Math.random() * 70) + 'vh';
    el.style.animation = `${goRight ? 'swimRight' : 'swimLeft'} ${10 + Math.random() * 8}s linear forwards`;

  } else if (diff === 'medium') {
    // Shark â€” slower, more menacing
    const { svg, w, h } = createSharkSVG();
    const goRight = Math.random() > 0.5;
    el.classList.add('shark');
    el.innerHTML = `<div style="${goRight ? '' : 'transform: scaleX(-1);'}">${svg}</div>`;
    el.style.top = (10 + Math.random() * 65) + 'vh';
    el.style.animation = `${goRight ? 'swimRight' : 'swimLeft'} ${14 + Math.random() * 10}s linear forwards`;

  } else {
    // Kraken tentacle rising from bottom
    const { svg, w, h } = createTentacleSVG();
    el.classList.add('tentacle');
    el.innerHTML = svg;
    el.style.left = (10 + Math.random() * 80) + 'vw';
    el.style.bottom = '0';
    el.style.animation = `tentacleRise ${16 + Math.random() * 10}s ease-in-out forwards`;
  }

  creaturesEl.appendChild(el);

  // Clean up after animation
  el.addEventListener('animationend', () => el.remove());
}

function startCreatureSpawner(diff) {
  clearInterval(creatureInterval);
  // Clear existing creatures
  creaturesEl.innerHTML = '';

  const intervals = { easy: [6000, 12000], medium: [10000, 18000], hard: [12000, 22000] };
  const [min, max] = intervals[diff];

  function scheduleNext() {
    const delay = min + Math.random() * (max - min);
    creatureInterval = setTimeout(() => {
      spawnCreature(diff);
      scheduleNext();
    }, delay);
  }

  // Spawn first one after a short delay
  setTimeout(() => spawnCreature(diff), 2000 + Math.random() * 3000);
  scheduleNext();
}

// === GAME LOGIC ===
const DIFFICULTIES = {
  easy:   { rows: 9,  cols: 9,  mines: 10 },
  medium: { rows: 16, cols: 16, mines: 40 },
  hard:   { rows: 16, cols: 30, mines: 99 },
};

const THEME_TEXT = {
  easy:   { subtitle: 'navigate the shallows',   depth: 'depth: shoreline',     name: 'Shallows' },
  medium: { subtitle: 'descend to the deep sea', depth: 'depth: 2,000 meters',  name: 'Deep Sea' },
  hard:   { subtitle: 'survive the abyss',       depth: 'depth: 6,000 meters',  name: 'The Abyss' },
};

let difficulty = 'easy';
let rows, cols, totalMines;
let board = [];
let gameStarted = false;
let gameOver = false;
let timer = 0;
let timerInterval = null;
let flagsPlaced = 0;
let cellsRevealed = 0;

const gridEl = document.getElementById('grid');
const mineDisplay = document.getElementById('mineDisplay');
const timerDisplay = document.getElementById('timerDisplay');
const resetBtn = document.getElementById('resetBtn');
const overlay = document.getElementById('overlay');
const overlayIcon = document.getElementById('overlayIcon');
const overlayTitle = document.getElementById('overlayTitle');
const overlayStats = document.getElementById('overlayStats');
const overlayBtn = document.getElementById('overlayBtn');
const subtitleText = document.getElementById('subtitleText');
const depthLabel = document.getElementById('depthLabel');

function applyTheme(diff) {
  document.body.className = `theme-${diff}`;
  subtitleText.textContent = THEME_TEXT[diff].subtitle;
  depthLabel.textContent = THEME_TEXT[diff].depth;
  startCreatureSpawner(diff);
}

document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelector('.diff-btn.active').classList.remove('active');
    btn.classList.add('active');
    difficulty = btn.dataset.diff;
    applyTheme(difficulty);
    initGame();
  });
});

resetBtn.addEventListener('click', initGame);
overlayBtn.addEventListener('click', () => {
  overlay.classList.remove('show');
  initGame();
});

function initGame() {
  const cfg = DIFFICULTIES[difficulty];
  rows = cfg.rows;
  cols = cfg.cols;
  totalMines = cfg.mines;

  board = [];
  gameStarted = false;
  gameOver = false;
  flagsPlaced = 0;
  cellsRevealed = 0;
  timer = 0;
  clearInterval(timerInterval);
  timerInterval = null;

  mineDisplay.textContent = totalMines;
  timerDisplay.textContent = '000';
  overlay.classList.remove('show');

  for (let r = 0; r < rows; r++) {
    board[r] = [];
    for (let c = 0; c < cols; c++) {
      board[r][c] = { mine: false, revealed: false, flagged: false, adjacent: 0 };
    }
  }
  renderGrid();
}

function placeMines(safeR, safeC) {
  const safe = new Set();
  for (let dr = -1; dr <= 1; dr++)
    for (let dc = -1; dc <= 1; dc++)
      safe.add(`${safeR + dr},${safeC + dc}`);

  let placed = 0;
  while (placed < totalMines) {
    const r = Math.floor(Math.random() * rows);
    const c = Math.floor(Math.random() * cols);
    if (!board[r][c].mine && !safe.has(`${r},${c}`)) {
      board[r][c].mine = true;
      placed++;
    }
  }

  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++) {
      if (board[r][c].mine) continue;
      let count = 0;
      forNeighbors(r, c, (nr, nc) => { if (board[nr][nc].mine) count++; });
      board[r][c].adjacent = count;
    }
}

function forNeighbors(r, c, fn) {
  for (let dr = -1; dr <= 1; dr++)
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) fn(nr, nc);
    }
}

function renderGrid() {
  gridEl.innerHTML = '';
  gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;

  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.addEventListener('click', () => handleClick(r, c));
      cell.addEventListener('contextmenu', (e) => { e.preventDefault(); handleRightClick(r, c); });

      let pressTimer;
      cell.addEventListener('touchstart', (e) => {
        pressTimer = setTimeout(() => { e.preventDefault(); handleRightClick(r, c); }, 400);
      }, { passive: false });
      cell.addEventListener('touchend', () => clearTimeout(pressTimer));
      cell.addEventListener('touchmove', () => clearTimeout(pressTimer));

      gridEl.appendChild(cell);
    }
}

function getCell(r, c) { return gridEl.children[r * cols + c]; }

function handleClick(r, c) {
  if (gameOver) return;
  const data = board[r][c];
  if (data.flagged || data.revealed) return;
  if (!gameStarted) { gameStarted = true; placeMines(r, c); startTimer(); }
  if (data.mine) { triggerLoss(r, c); return; }
  reveal(r, c);
  checkWin();
}

function handleRightClick(r, c) {
  if (gameOver) return;
  const data = board[r][c];
  if (data.revealed) return;
  if (!gameStarted) { gameStarted = true; placeMines(r, c); startTimer(); }
  data.flagged = !data.flagged;
  flagsPlaced += data.flagged ? 1 : -1;
  getCell(r, c).classList.toggle('flagged', data.flagged);
  mineDisplay.textContent = totalMines - flagsPlaced;
  checkWin();
}

function reveal(r, c) {
  const data = board[r][c];
  if (data.revealed || data.flagged) return;
  data.revealed = true;
  cellsRevealed++;
  const cell = getCell(r, c);
  cell.classList.add('revealed');
  if (data.adjacent > 0) {
    cell.classList.add(`n${data.adjacent}`);
    cell.textContent = data.adjacent;
  } else {
    cell.classList.add('empty');
    forNeighbors(r, c, (nr, nc) => reveal(nr, nc));
  }
}

function triggerLoss(hitR, hitC) {
  gameOver = true;
  clearInterval(timerInterval);
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++) {
      if (board[r][c].mine) {
        const cell = getCell(r, c);
        cell.classList.add(r === hitR && c === hitC ? 'jelly-hit' : 'jelly-shown');
        cell.innerHTML = '<span class="jelly-icon">ðŸª¼</span>';
      }
    }
  setTimeout(() => {
    overlayIcon.textContent = 'ðŸª¼';
    overlayTitle.textContent = 'STUNG!';
    overlayTitle.className = 'overlay-title lose';
    overlayStats.textContent = `Survived ${timer}s Â· ${cellsRevealed} tiles explored`;
    overlay.classList.add('show');
  }, 600);
}

function checkWin() {
  if (cellsRevealed === rows * cols - totalMines) {
    gameOver = true;
    clearInterval(timerInterval);
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        if (board[r][c].mine && !board[r][c].flagged) {
          board[r][c].flagged = true;
          getCell(r, c).classList.add('flagged');
        }
    mineDisplay.textContent = '0';
    setTimeout(() => {
      overlayIcon.textContent = 'ðŸš';
      overlayTitle.textContent = 'OCEAN CLEARED!';
      overlayTitle.className = 'overlay-title win';
      overlayStats.textContent = `Cleared in ${timer}s Â· ${THEME_TEXT[difficulty].name}`;
      overlay.classList.add('show');
    }, 400);
  }
}

function startTimer() {
  timer = 0;
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    timer++;
    timerDisplay.textContent = String(timer).padStart(3, '0');
    if (timer >= 999) clearInterval(timerInterval);
  }, 1000);
}

applyTheme('easy');
initGame();
</script>
</body>
</html>
