<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tidal Sweep</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Lilita+One&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --cell-size: 36px;
    --transition-speed: 0.6s;
  }

  /* ===== SHALLOWS ===== */
  body.theme-easy {
    --bg: #1a3a4a;
    --surface: #1e4252;
    --border: #2e6070;
    --text: #a0d0d8;
    --accent: #2ec4a8;
    --accent-dim: #1a9880;
    --danger: #e05080;
    --warn: #d8a030;
    --cell-bg: #1c4858;
    --cell-hover: #245868;
    --cell-revealed: #16323e;
    --title-from: #2ec4a8;
    --title-to: #48b0d8;
    --overlay-bg: rgba(22, 50, 62, 0.88);
    --footer-color: #5a9098;
    --depth-color: #4a7880;
    --bubble-color: rgba(180, 230, 240, 0.12);
    --bubble-border: rgba(180, 230, 240, 0.1);
    --shadow-glow: rgba(40, 180, 170, 0.08);
    --sand-bar: rgba(0, 0, 0, 0.15);
    --wave1: rgba(80, 180, 200, 0.06);
    --wave2: rgba(60, 160, 180, 0.04);
    --wave3: rgba(100, 200, 210, 0.05);
  }

  /* ===== DEEP SEA ===== */
  body.theme-medium {
    --bg: #061a2e;
    --surface: #0a2440;
    --border: #184060;
    --text: #90c0e0;
    --accent: #00d4b8;
    --accent-dim: #009080;
    --danger: #e84488;
    --warn: #e8a020;
    --cell-bg: #0e2e50;
    --cell-hover: #143a60;
    --cell-revealed: #081c32;
    --title-from: #00d4b8;
    --title-to: #3090e0;
    --overlay-bg: rgba(6, 26, 46, 0.88);
    --footer-color: #2a5878;
    --depth-color: #1e4060;
    --bubble-color: rgba(120, 200, 255, 0.1);
    --bubble-border: rgba(100, 180, 255, 0.06);
    --shadow-glow: rgba(0, 100, 200, 0.1);
    --sand-bar: rgba(0, 0, 0, 0.25);
    --wave1: rgba(30, 100, 180, 0.05);
    --wave2: rgba(20, 80, 150, 0.04);
    --wave3: rgba(40, 120, 200, 0.03);
  }

  /* ===== THE ABYSS ===== */
  body.theme-hard {
    --bg: #020810;
    --surface: #040e1a;
    --border: #0e2038;
    --text: #5080a8;
    --accent: #00a8c0;
    --accent-dim: #006878;
    --danger: #c03068;
    --warn: #b88018;
    --cell-bg: #061428;
    --cell-hover: #0a1e38;
    --cell-revealed: #030a14;
    --title-from: #00a8c0;
    --title-to: #1860a0;
    --overlay-bg: rgba(2, 8, 16, 0.92);
    --footer-color: #152840;
    --depth-color: #0e1828;
    --bubble-color: rgba(60, 120, 180, 0.05);
    --bubble-border: rgba(60, 120, 180, 0.03);
    --shadow-glow: rgba(0, 60, 120, 0.08);
    --sand-bar: rgba(0, 0, 0, 0.4);
    --wave1: rgba(10, 40, 80, 0.04);
    --wave2: rgba(8, 30, 60, 0.03);
    --wave3: rgba(12, 50, 90, 0.02);
  }

  body {
    color: var(--text);
    font-family: 'Fredoka', sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    overflow: hidden;
    position: relative;
    background: var(--bg);
    transition:
      background var(--transition-speed) ease,
      color var(--transition-speed) ease;
  }

  /* === WAVES === */
  .waves {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 1;
    overflow: hidden;
  }

  .wave {
    position: absolute;
    width: 300%;
    height: 100%;
    top: 0;
    left: -100%;
  }

  .wave-1 {
    background: repeating-linear-gradient(90deg, transparent 0%, var(--wave1) 12%, transparent 24%);
    animation: waveDrift1 18s ease-in-out infinite;
  }
  .wave-2 {
    background: repeating-linear-gradient(88deg, transparent 0%, var(--wave2) 15%, transparent 30%);
    animation: waveDrift2 24s ease-in-out infinite;
  }
  .wave-3 {
    background: repeating-linear-gradient(92deg, transparent 0%, var(--wave3) 10%, transparent 20%);
    animation: waveDrift3 14s ease-in-out infinite;
  }

  @keyframes waveDrift1 {
    0%, 100% { transform: translateX(0%) translateY(0); }
    50% { transform: translateX(15%) translateY(8px); }
  }
  @keyframes waveDrift2 {
    0%, 100% { transform: translateX(0%) translateY(0); }
    50% { transform: translateX(-10%) translateY(-6px); }
  }
  @keyframes waveDrift3 {
    0%, 100% { transform: translateX(0%) translateY(0); }
    50% { transform: translateX(8%) translateY(5px); }
  }

  /* === BUBBLES === */
  .bubbles {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 2;
    overflow: hidden;
  }

  .bubble {
    position: absolute;
    bottom: -20px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, var(--bubble-color), transparent);
    border: 1px solid var(--bubble-border);
    animation: bubbleRise linear infinite;
    transition: background var(--transition-speed) ease, border-color var(--transition-speed) ease;
  }

  @keyframes bubbleRise {
    0% { transform: translateY(0) translateX(0) scale(1); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 0.6; }
    100% { transform: translateY(-110vh) translateX(40px) scale(0.6); opacity: 0; }
  }

  /* === CREATURES === */
  .creatures {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 3;
    overflow: hidden;
  }

  .creature {
    position: absolute;
    opacity: 0;
    will-change: transform;
  }

  /* Fish (Shallows) */
  .fish {
    font-size: 0;
    filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
  }

  .fish-body {
    position: relative;
    display: inline-block;
  }

  .fish-body svg {
    display: block;
  }

  /* Shark (Deep Sea) */
  .shark {
    font-size: 0;
    filter: drop-shadow(0 4px 16px rgba(0, 0, 0, 0.4));
  }

  /* Kraken tentacle (Abyss) */
  .tentacle {
    filter: drop-shadow(0 0 20px rgba(120, 0, 60, 0.3));
  }

  /* Swim animations */
  @keyframes swimRight {
    0% { transform: translateX(-150px) translateY(0px); opacity: 0; }
    5% { opacity: 1; }
    50% { transform: translateX(50vw) translateY(-20px); opacity: 1; }
    95% { opacity: 1; }
    100% { transform: translateX(calc(100vw + 150px)) translateY(10px); opacity: 0; }
  }

  @keyframes swimLeft {
    0% { transform: translateX(calc(100vw + 150px)) translateY(0px); opacity: 0; }
    5% { opacity: 1; }
    50% { transform: translateX(50vw) translateY(15px); opacity: 1; }
    95% { opacity: 1; }
    100% { transform: translateX(-150px) translateY(-10px); opacity: 0; }
  }

  @keyframes tentacleRise {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
    10% { opacity: 0.6; }
    40% { transform: translateY(20vh) rotate(-8deg); opacity: 0.7; }
    60% { transform: translateY(15vh) rotate(5deg); opacity: 0.6; }
    90% { opacity: 0.3; }
    100% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
  }

  @keyframes fishWiggle {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(2deg); }
    75% { transform: rotate(-2deg); }
  }

  @keyframes tailSwish {
    0%, 100% { transform: scaleX(1); }
    50% { transform: scaleX(0.85); }
  }

  .game-container {
    position: relative;
    z-index: 10;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px;
    box-shadow:
      0 0 60px var(--shadow-glow),
      inset 0 1px 0 rgba(255, 255, 255, 0.04);
    max-width: 95vw;
    transition:
      background var(--transition-speed) ease,
      border-color var(--transition-speed) ease,
      box-shadow var(--transition-speed) ease;
  }

  .header { text-align: center; margin-bottom: 20px; }

  .title {
    font-family: 'Lilita One', cursive;
    font-size: 34px;
    background: linear-gradient(135deg, var(--title-from), var(--title-to), var(--title-from));
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: shimmer 4s ease-in-out infinite;
    letter-spacing: 3px;
    margin-bottom: 2px;
  }

  @keyframes shimmer {
    0%, 100% { background-position: 0% center; }
    50% { background-position: 200% center; }
  }

  .subtitle {
    font-size: 11px;
    color: var(--footer-color);
    letter-spacing: 4px;
    text-transform: uppercase;
    font-weight: 500;
    transition: color var(--transition-speed) ease;
  }

  .difficulty-bar {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-bottom: 16px;
  }

  .diff-btn {
    background: var(--cell-bg);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Fredoka', sans-serif;
    font-size: 12px;
    font-weight: 600;
    padding: 8px 18px;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.25s;
    letter-spacing: 1px;
  }

  .diff-btn:hover { border-color: var(--accent-dim); }

  .diff-btn.active {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(0, 200, 180, 0.08);
    box-shadow: 0 0 16px rgba(0, 200, 180, 0.12);
  }

  .diff-label { font-size: 13px; }
  .diff-info { font-size: 9px; opacity: 0.5; display: block; margin-top: 2px; }

  .status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding: 10px 16px;
    background: var(--sand-bar);
    border-radius: 12px;
    border: 1px solid var(--border);
    transition: background var(--transition-speed) ease, border-color var(--transition-speed) ease;
  }

  .stat {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 15px;
    font-weight: 700;
  }

  .stat-icon { font-size: 18px; }
  .jelly-count { color: var(--danger); transition: color var(--transition-speed) ease; }
  .timer-count { color: var(--warn); transition: color var(--transition-speed) ease; }

  .reset-btn {
    background: rgba(0, 200, 180, 0.08);
    border: 1px solid var(--border);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.25s;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .reset-btn:hover {
    border-color: var(--accent);
    box-shadow: 0 0 14px rgba(0, 200, 180, 0.2);
    transform: rotate(180deg);
  }

  .grid-wrapper { display: flex; justify-content: center; }

  .grid {
    display: inline-grid;
    gap: 2px;
    background: var(--sand-bar);
    padding: 6px;
    border-radius: 12px;
    border: 1px solid var(--border);
    transition: background var(--transition-speed) ease, border-color var(--transition-speed) ease;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    background: var(--cell-bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    font-weight: 700;
    font-family: 'Fredoka', sans-serif;
    transition: background 0.15s ease, border-color 0.15s ease;
    user-select: none;
    -webkit-user-select: none;
    position: relative;
  }

  .cell:hover:not(.revealed):not(.game-over-cell) {
    background: var(--cell-hover);
    border-color: rgba(0, 200, 180, 0.3);
    box-shadow: 0 0 8px rgba(0, 200, 180, 0.08);
  }

  .cell.revealed {
    background: var(--cell-revealed);
    border-color: rgba(255, 255, 255, 0.03);
    cursor: default;
  }

  .cell.revealed.empty { background: var(--cell-revealed); }

  .cell.flagged::after {
    content: 'ðŸš©';
    font-size: 16px;
    animation: flagDrop 0.25s ease-out;
  }

  @keyframes flagDrop {
    0% { transform: translateY(-8px); opacity: 0; }
    100% { transform: translateY(0); opacity: 1; }
  }

  .cell.jelly-hit {
    background: rgba(232, 68, 136, 0.25) !important;
    border-color: var(--danger) !important;
    animation: jellyZap 0.4s ease-out;
  }

  @keyframes jellyZap {
    0% { transform: scale(1); }
    25% { transform: scale(1.15); }
    50% { transform: scale(0.95); }
    100% { transform: scale(1); }
  }

  .cell.jelly-shown { background: rgba(232, 68, 136, 0.08); }

  .cell .jelly-icon {
    font-size: 17px;
    filter: drop-shadow(0 0 4px rgba(232, 68, 136, 0.4));
  }

  /* Number colors per theme */
  body.theme-easy .cell.n1 { color: #38a8cc; }
  body.theme-easy .cell.n2 { color: #20b890; }
  body.theme-easy .cell.n3 { color: #d05070; }
  body.theme-easy .cell.n4 { color: #8860cc; }
  body.theme-easy .cell.n5 { color: #cc7030; }
  body.theme-easy .cell.n6 { color: #30b890; }
  body.theme-easy .cell.n7 { color: #a070cc; }
  body.theme-easy .cell.n8 { color: #6890a0; }

  body.theme-medium .cell.n1 { color: #44bbff; }
  body.theme-medium .cell.n2 { color: #00e4c8; }
  body.theme-medium .cell.n3 { color: #e84488; }
  body.theme-medium .cell.n4 { color: #9966ee; }
  body.theme-medium .cell.n5 { color: #f07030; }
  body.theme-medium .cell.n6 { color: #44ddaa; }
  body.theme-medium .cell.n7 { color: #cc88ff; }
  body.theme-medium .cell.n8 { color: #607890; }

  body.theme-hard .cell.n1 { color: #2878b8; }
  body.theme-hard .cell.n2 { color: #009888; }
  body.theme-hard .cell.n3 { color: #b03060; }
  body.theme-hard .cell.n4 { color: #6644aa; }
  body.theme-hard .cell.n5 { color: #a05820; }
  body.theme-hard .cell.n6 { color: #208868; }
  body.theme-hard .cell.n7 { color: #8860aa; }
  body.theme-hard .cell.n8 { color: #384858; }

  /* OVERLAY */
  .overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: var(--overlay-bg);
    backdrop-filter: blur(6px);
    z-index: 50;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.3s ease;
    transition: background var(--transition-speed) ease;
  }

  .overlay.show { display: flex; }

  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  .overlay-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 40px 52px;
    text-align: center;
    box-shadow: 0 0 80px var(--shadow-glow), 0 0 30px rgba(0, 0, 0, 0.5);
    animation: surfaceUp 0.4s ease;
    transition: background var(--transition-speed) ease, border-color var(--transition-speed) ease;
  }

  @keyframes surfaceUp {
    from { transform: translateY(30px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  .overlay-icon { font-size: 52px; margin-bottom: 12px; }

  .overlay-title {
    font-family: 'Lilita One', cursive;
    font-size: 24px;
    margin-bottom: 8px;
    letter-spacing: 2px;
  }

  .overlay-title.win { color: var(--accent); text-shadow: 0 0 24px rgba(0, 200, 180, 0.35); }
  .overlay-title.lose { color: var(--danger); text-shadow: 0 0 24px rgba(232, 68, 136, 0.35); }

  .overlay-stats {
    font-size: 13px;
    color: var(--footer-color);
    margin-bottom: 24px;
    transition: color var(--transition-speed) ease;
  }

  .overlay-btn {
    background: linear-gradient(135deg, var(--accent), var(--title-to));
    color: #fff;
    border: none;
    font-family: 'Lilita One', cursive;
    font-size: 15px;
    padding: 12px 32px;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.25s;
    letter-spacing: 2px;
    box-shadow: 0 4px 20px var(--shadow-glow);
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }

  .overlay-btn:hover {
    box-shadow: 0 4px 30px var(--shadow-glow);
    transform: translateY(-2px);
  }

  .footer {
    margin-top: 14px;
    text-align: center;
    font-size: 11px;
    color: var(--footer-color);
    letter-spacing: 1px;
    transition: color var(--transition-speed) ease;
  }

  .footer span { color: var(--accent-dim); }

  .depth-label {
    display: inline-block;
    margin-top: 6px;
    font-size: 9px;
    color: var(--depth-color);
    letter-spacing: 3px;
    text-transform: uppercase;
    transition: color var(--transition-speed) ease;
  }

  @media (max-width: 600px) {
    :root { --cell-size: 30px; }
    .game-container { padding: 14px; }
    .title { font-size: 26px; }
    .diff-btn { padding: 6px 12px; font-size: 11px; }
    .overlay-box { padding: 28px 24px; }
  }
</style>
</head>
<body class="theme-easy">

<div class="waves">
  <div class="wave wave-1"></div>
  <div class="wave wave-2"></div>
  <div class="wave wave-3"></div>
</div>

<div class="bubbles" id="bubbles"></div>
<div class="creatures" id="creatures"></div>

<div class="game-container">
  <div class="header">
    <div class="title">TIDAL SWEEP</div>
    <div class="subtitle" id="subtitleText">navigate the shallows</div>
  </div>

  <div class="difficulty-bar">
    <button class="diff-btn active" data-diff="easy">
      <span class="diff-label">Shallows</span>
      <span class="diff-info">9Ã—9 Â· 10 jelly</span>
    </button>
    <button class="diff-btn" data-diff="medium">
      <span class="diff-label">Deep Sea</span>
      <span class="diff-info">16Ã—16 Â· 40 jelly</span>
    </button>
    <button class="diff-btn" data-diff="hard">
      <span class="diff-label">The Abyss</span>
      <span class="diff-info">16Ã—30 Â· 99 jelly</span>
    </button>
  </div>

  <div class="status-bar">
    <div class="stat jelly-count">
      <span class="stat-icon">ðŸª¼</span>
      <span id="mineDisplay">10</span>
    </div>
    <button class="reset-btn" id="resetBtn" title="New Dive">ðŸŒŠ</button>
    <div class="stat timer-count">
      <span class="stat-icon">ðŸ«§</span>
      <span id="timerDisplay">000</span>
    </div>
  </div>

  <div class="grid-wrapper">
    <div class="grid" id="grid"></div>
  </div>

  <div class="footer">
    left click â€” reveal &nbsp;|&nbsp; right click â€” <span>flag</span>
    <div class="depth-label" id="depthLabel">depth: shoreline</div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="overlay-box">
    <div class="overlay-icon" id="overlayIcon"></div>
    <div class="overlay-title" id="overlayTitle"></div>
    <div class="overlay-stats" id="overlayStats"></div>
    <button class="overlay-btn" id="overlayBtn">DIVE AGAIN</button>
  </div>
</div>

<script>
// === BUBBLES ===
const bubblesEl = document.getElementById('bubbles');
for (let i = 0; i < 20; i++) {
  const b = document.createElement('div');
  b.className = 'bubble';
  const size = 4 + Math.random() * 16;
  b.style.width = size + 'px';
  b.style.height = size + 'px';
  b.style.left = Math.random() * 100 + '%';
  b.style.animationDuration = (8 + Math.random() * 14) + 's';
  b.style.animationDelay = (Math.random() * 10) + 's';
  bubblesEl.appendChild(b);
}

// === CREATURES ===
const creaturesEl = document.getElementById('creatures');
let creatureInterval = null;

function createFishSVG() {
  // Colorful tropical fish
  const colors = [
    ['#FFB347','#FF6B35'],
    ['#4ECDC4','#2AB7A9'],
    ['#FF6B8A','#EE4466'],
    ['#95E1D3','#5CC8B0'],
    ['#F8E16C','#E8C84A'],
    ['#A8D8EA','#6BB5D0'],
  ];
  const [body, fin] = colors[Math.floor(Math.random() * colors.length)];
  const size = 30 + Math.random() * 25;
  const w = size * 1.8;
  const h = size;

  const svg = `<svg width="${w}" height="${h}" viewBox="0 0 54 30" xmlns="http://www.w3.org/2000/svg">
    <g>
      <!-- Tail -->
      <path d="M4 15 L0 5 L10 15 L0 25 Z" fill="${fin}" opacity="0.8"/>
      <!-- Body -->
      <ellipse cx="28" cy="15" rx="18" ry="12" fill="${body}"/>
      <!-- Stripe -->
      <ellipse cx="28" cy="15" rx="18" ry="12" fill="none" stroke="rgba(255,255,255,0.25)" stroke-width="1.5"/>
      <path d="M24 4 Q26 15 24 26" stroke="rgba(255,255,255,0.3)" stroke-width="1.5" fill="none"/>
      <!-- Dorsal fin -->
      <path d="M22 4 Q28 -2 34 4" fill="${fin}" opacity="0.7"/>
      <!-- Eye -->
      <circle cx="36" cy="12" r="3" fill="white"/>
      <circle cx="37" cy="11.5" r="1.5" fill="#222"/>
      <!-- Mouth -->
      <path d="M44 15 Q46 16 44 17" stroke="#333" stroke-width="0.8" fill="none"/>
    </g>
  </svg>`;
  return { svg, w, h };
}

function createSharkSVG() {
  const size = 80 + Math.random() * 60;  // Slightly larger range for variety: 80â€“140 px height
  const w = size * 2.4;                  // Wider aspect for classic side profile
  const h = size;

  const svg = `<svg width="${w}" height="${h}" viewBox="0 0 288 120" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(0,10) scale(1.1)">
      <!-- Body base: torpedo shape, dark slate gray top -->
      <path d="M20 60 Q80 20 180 50 Q260 70 268 60 Q260 100 180 90 Q80 110 20 80 Z" fill="#2c3e50" stroke="#1a252f" stroke-width="2"/>

      <!-- White underbelly with sharp demarcation -->
      <path d="M20 80 Q80 110 180 90 Q260 100 268 60 L268 120 L20 120 Z" fill="#f0f8ff" opacity="0.95"/>

      <!-- Snout shading for pointed look -->
      <ellipse cx="40" cy="60" rx="25" ry="18" fill="#34495e" opacity="0.8"/>

      <!-- Dorsal fin (tall, triangular, classic great white shape) -->
      <path d="M120 30 L140 0 L160 30 L150 50 Z" fill="#2c3e50" stroke="#1a252f" stroke-width="1.5"/>

      <!-- Pectoral fins (wide, triangular, angled back) -->
      <path d="M100 70 L70 100 L90 80 Z" fill="#2c3e50" opacity="0.9"/>
      <path d="M180 70 L210 100 L190 80 Z" fill="#2c3e50" opacity="0.85"/>

      <!-- Gill slits (5 parallel vertical lines, slanted slightly) -->
      <g stroke="#1a252f" stroke-width="2" opacity="0.7">
        <line x1="80" y1="55" x2="80" y2="75"/>
        <line x1="85" y1="54" x2="85" y2="76"/>
        <line x1="90" y1="53" x2="90" y2="77"/>
        <line x1="95" y1="52" x2="95" y2="78"/>
        <line x1="100" y1="51" x2="100" y2="79"/>
      </g>

      <!-- Eye: small, black, high on head, realistic placement -->
      <circle cx="55" cy="50" r="5" fill="#0a0a0a"/>
      <circle cx="57" cy="49" r="2" fill="#ffffff" opacity="0.4"/> <!-- tiny highlight -->

      <!-- Open mouth with serrated teeth (classic jagged triangle rows) -->
      <path d="M30 65 Q50 80 70 70 Q60 85 40 90 Z" fill="#111" stroke="#000" stroke-width="1.5"/>
      <!-- Upper teeth -->
      <g fill="#ddd" stroke="#aaa" stroke-width="0.5">
        <polygon points="35,68 38,62 41,68"/>
        <polygon points="42,70 45,64 48,70"/>
        <polygon points="49,72 52,66 55,72"/>
        <polygon points="56,74 59,68 62,74"/>
      </g>
      <!-- Lower teeth (offset) -->
      <g fill="#ddd" stroke="#aaa" stroke-width="0.5">
        <polygon points="38,82 41,88 44,82"/>
        <polygon points="45,84 48,90 51,84"/>
        <polygon points="52,86 55,92 58,86"/>
      </g>

      <!-- Tail fin (heterocercal: upper lobe longer) -->
      <path d="M260 60 L288 40 L280 80 L260 100 Z" fill="#2c3e50" stroke="#1a252f" stroke-width="2"/>
      <path d="M260 80 L288 100 L280 60 L260 60 Z" fill="#34495e" opacity="0.8"/>
    </g>
  </svg>`;

  return { svg, w, h };
}
 
function createTentacleSVG() {
  const w = 60 + Math.random() * 40;
  const h = 400;
  const hue = Math.random() > 0.5 ? '280' : '320';
  const color1 = `hsla(${hue}, 40%, 25%, 0.6)`;
  const color2 = `hsla(${hue}, 50%, 15%, 0.8)`;
  const sucker = `hsla(${hue}, 30%, 35%, 0.4)`;

  // Generate wavy tentacle path
  const midX = w / 2;
  let d = `M${midX} ${h}`;
  const segments = 12;
  for (let i = 0; i < segments; i++) {
    const y = h - (h / segments) * (i + 1);
    const sway = Math.sin(i * 0.8) * (15 + Math.random() * 10);
    const cpY = y + (h / segments) * 0.5;
    d += ` Q${midX + sway * 1.5} ${cpY} ${midX + sway} ${y}`;
  }

  // Taper width
  const svg = `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="tentGrad" x1="0" y1="1" x2="0" y2="0">
        <stop offset="0%" stop-color="${color2}"/>
        <stop offset="100%" stop-color="${color1}"/>
      </linearGradient>
    </defs>
    <!-- Shadow tentacle -->
    <path d="${d}" stroke="url(#tentGrad)" stroke-width="${w * 0.5}" fill="none" stroke-linecap="round" opacity="0.5"/>
    <!-- Main tentacle -->
    <path d="${d}" stroke="url(#tentGrad)" stroke-width="${w * 0.35}" fill="none" stroke-linecap="round"/>
    <!-- Highlight -->
    <path d="${d}" stroke="rgba(200,150,255,0.08)" stroke-width="${w * 0.12}" fill="none" stroke-linecap="round"/>
    <!-- Suckers -->
    ${Array.from({length: 8}, (_, i) => {
      const frac = (i + 1) / 10;
      const sy = h - frac * h;
      const sx = midX + Math.sin((i+1) * 0.8) * (15 + 5) * 0.6;
      const sr = 3 + (1 - frac) * 4;
      return `<circle cx="${sx}" cy="${sy}" r="${sr}" fill="${sucker}" opacity="${0.3 + frac * 0.3}"/>`;
    }).join('')}
    <!-- Bioluminescent glow spots -->
    ${Array.from({length: 4}, (_, i) => {
      const frac = (i + 1) / 6;
      const gy = h - frac * h;
      const gx = midX + Math.sin((i+1) * 0.8) * 12;
      return `<circle cx="${gx}" cy="${gy}" r="2" fill="rgba(160, 200, 255, 0.4)" opacity="${0.3 + Math.random() * 0.4}">
        <animate attributeName="opacity" values="0.2;0.6;0.2" dur="${2 + Math.random() * 2}s" repeatCount="indefinite"/>
      </circle>`;
    }).join('')}
  </svg>`;
  return { svg, w, h };
}

function spawnCreature(diff) {
  const el = document.createElement('div');
  el.className = 'creature';

  if (diff === 'easy') {
    // Tropical fish swimming left or right
    const { svg, w, h } = createFishSVG();
    const goRight = Math.random() > 0.5;
    el.classList.add('fish');
    el.innerHTML = `<div class="fish-body" style="${goRight ? '' : 'transform: scaleX(-1);'}">${svg}</div>`;
    el.style.top = (15 + Math.random() * 70) + 'vh';
    el.style.animation = `${goRight ? 'swimRight' : 'swimLeft'} ${10 + Math.random() * 8}s linear forwards`;

  } else if (diff === 'medium') {
    // Shark â€” slower, more menacing
    const { svg, w, h } = createSharkSVG();
    const goRight = Math.random() > 0.5;
    el.classList.add('shark');
    el.innerHTML = `<div style="${goRight ? '' : 'transform: scaleX(-1);'}">${svg}</div>`;
    el.style.top = (10 + Math.random() * 65) + 'vh';
    el.style.animation = `${goRight ? 'swimRight' : 'swimLeft'} ${14 + Math.random() * 10}s linear forwards`;

  } else {
    // Kraken tentacle rising from bottom
    const { svg, w, h } = createTentacleSVG();
    el.classList.add('tentacle');
    el.innerHTML = svg;
    el.style.left = (10 + Math.random() * 80) + 'vw';
    el.style.bottom = '0';
    el.style.animation = `tentacleRise ${16 + Math.random() * 10}s ease-in-out forwards`;
  }

  creaturesEl.appendChild(el);

  // Clean up after animation
  el.addEventListener('animationend', () => el.remove());
}

function startCreatureSpawner(diff) {
  clearInterval(creatureInterval);
  // Clear existing creatures
  creaturesEl.innerHTML = '';

  const intervals = { easy: [6000, 12000], medium: [10000, 18000], hard: [12000, 22000] };
  const [min, max] = intervals[diff];

  function scheduleNext() {
    const delay = min + Math.random() * (max - min);
    creatureInterval = setTimeout(() => {
      spawnCreature(diff);
      scheduleNext();
    }, delay);
  }

  // Spawn first one after a short delay
  setTimeout(() => spawnCreature(diff), 2000 + Math.random() * 3000);
  scheduleNext();
}

// === GAME LOGIC ===
const DIFFICULTIES = {
  easy:   { rows: 9,  cols: 9,  mines: 10 },
  medium: { rows: 16, cols: 16, mines: 40 },
  hard:   { rows: 16, cols: 30, mines: 99 },
};

const THEME_TEXT = {
  easy:   { subtitle: 'navigate the shallows',   depth: 'depth: shoreline',     name: 'Shallows' },
  medium: { subtitle: 'descend to the deep sea', depth: 'depth: 2,000 meters',  name: 'Deep Sea' },
  hard:   { subtitle: 'survive the abyss',       depth: 'depth: 6,000 meters',  name: 'The Abyss' },
};

let difficulty = 'easy';
let rows, cols, totalMines;
let board = [];
let gameStarted = false;
let gameOver = false;
let timer = 0;
let timerInterval = null;
let flagsPlaced = 0;
let cellsRevealed = 0;

const gridEl = document.getElementById('grid');
const mineDisplay = document.getElementById('mineDisplay');
const timerDisplay = document.getElementById('timerDisplay');
const resetBtn = document.getElementById('resetBtn');
const overlay = document.getElementById('overlay');
const overlayIcon = document.getElementById('overlayIcon');
const overlayTitle = document.getElementById('overlayTitle');
const overlayStats = document.getElementById('overlayStats');
const overlayBtn = document.getElementById('overlayBtn');
const subtitleText = document.getElementById('subtitleText');
const depthLabel = document.getElementById('depthLabel');

function applyTheme(diff) {
  document.body.className = `theme-${diff}`;
  subtitleText.textContent = THEME_TEXT[diff].subtitle;
  depthLabel.textContent = THEME_TEXT[diff].depth;
  startCreatureSpawner(diff);
}

document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelector('.diff-btn.active').classList.remove('active');
    btn.classList.add('active');
    difficulty = btn.dataset.diff;
    applyTheme(difficulty);
    initGame();
  });
});

resetBtn.addEventListener('click', initGame);
overlayBtn.addEventListener('click', () => {
  overlay.classList.remove('show');
  initGame();
});

function initGame() {
  const cfg = DIFFICULTIES[difficulty];
  rows = cfg.rows;
  cols = cfg.cols;
  totalMines = cfg.mines;

  board = [];
  gameStarted = false;
  gameOver = false;
  flagsPlaced = 0;
  cellsRevealed = 0;
  timer = 0;
  clearInterval(timerInterval);
  timerInterval = null;

  mineDisplay.textContent = totalMines;
  timerDisplay.textContent = '000';
  overlay.classList.remove('show');

  for (let r = 0; r < rows; r++) {
    board[r] = [];
    for (let c = 0; c < cols; c++) {
      board[r][c] = { mine: false, revealed: false, flagged: false, adjacent: 0 };
    }
  }
  renderGrid();
}

function placeMines(safeR, safeC) {
  const safe = new Set();
  for (let dr = -1; dr <= 1; dr++)
    for (let dc = -1; dc <= 1; dc++)
      safe.add(`${safeR + dr},${safeC + dc}`);

  let placed = 0;
  while (placed < totalMines) {
    const r = Math.floor(Math.random() * rows);
    const c = Math.floor(Math.random() * cols);
    if (!board[r][c].mine && !safe.has(`${r},${c}`)) {
      board[r][c].mine = true;
      placed++;
    }
  }

  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++) {
      if (board[r][c].mine) continue;
      let count = 0;
      forNeighbors(r, c, (nr, nc) => { if (board[nr][nc].mine) count++; });
      board[r][c].adjacent = count;
    }
}

function forNeighbors(r, c, fn) {
  for (let dr = -1; dr <= 1; dr++)
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) fn(nr, nc);
    }
}

function renderGrid() {
  gridEl.innerHTML = '';
  gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;

  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.addEventListener('click', () => handleClick(r, c));
      cell.addEventListener('contextmenu', (e) => { e.preventDefault(); handleRightClick(r, c); });

      let pressTimer;
      cell.addEventListener('touchstart', (e) => {
        pressTimer = setTimeout(() => { e.preventDefault(); handleRightClick(r, c); }, 400);
      }, { passive: false });
      cell.addEventListener('touchend', () => clearTimeout(pressTimer));
      cell.addEventListener('touchmove', () => clearTimeout(pressTimer));

      gridEl.appendChild(cell);
    }
}

function getCell(r, c) { return gridEl.children[r * cols + c]; }

function handleClick(r, c) {
  if (gameOver) return;
  const data = board[r][c];
  if (data.flagged || data.revealed) return;
  if (!gameStarted) { gameStarted = true; placeMines(r, c); startTimer(); }
  if (data.mine) { triggerLoss(r, c); return; }
  reveal(r, c);
  checkWin();
}

function handleRightClick(r, c) {
  if (gameOver) return;
  const data = board[r][c];
  if (data.revealed) return;
  if (!gameStarted) { gameStarted = true; placeMines(r, c); startTimer(); }
  data.flagged = !data.flagged;
  flagsPlaced += data.flagged ? 1 : -1;
  getCell(r, c).classList.toggle('flagged', data.flagged);
  mineDisplay.textContent = totalMines - flagsPlaced;
  checkWin();
}

function reveal(r, c) {
  const data = board[r][c];
  if (data.revealed || data.flagged) return;
  data.revealed = true;
  cellsRevealed++;
  const cell = getCell(r, c);
  cell.classList.add('revealed');
  if (data.adjacent > 0) {
    cell.classList.add(`n${data.adjacent}`);
    cell.textContent = data.adjacent;
  } else {
    cell.classList.add('empty');
    forNeighbors(r, c, (nr, nc) => reveal(nr, nc));
  }
}

function triggerLoss(hitR, hitC) {
  gameOver = true;
  clearInterval(timerInterval);
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++) {
      if (board[r][c].mine) {
        const cell = getCell(r, c);
        cell.classList.add(r === hitR && c === hitC ? 'jelly-hit' : 'jelly-shown');
        cell.innerHTML = '<span class="jelly-icon">ðŸª¼</span>';
      }
    }
  setTimeout(() => {
    overlayIcon.textContent = 'ðŸª¼';
    overlayTitle.textContent = 'STUNG!';
    overlayTitle.className = 'overlay-title lose';
    overlayStats.textContent = `Survived ${timer}s Â· ${cellsRevealed} tiles explored`;
    overlay.classList.add('show');
  }, 600);
}

function checkWin() {
  if (cellsRevealed === rows * cols - totalMines) {
    gameOver = true;
    clearInterval(timerInterval);
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        if (board[r][c].mine && !board[r][c].flagged) {
          board[r][c].flagged = true;
          getCell(r, c).classList.add('flagged');
        }
    mineDisplay.textContent = '0';
    setTimeout(() => {
      overlayIcon.textContent = 'ðŸš';
      overlayTitle.textContent = 'OCEAN CLEARED!';
      overlayTitle.className = 'overlay-title win';
      overlayStats.textContent = `Cleared in ${timer}s Â· ${THEME_TEXT[difficulty].name}`;
      overlay.classList.add('show');
    }, 400);
  }
}

function startTimer() {
  timer = 0;
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    timer++;
    timerDisplay.textContent = String(timer).padStart(3, '0');
    if (timer >= 999) clearInterval(timerInterval);
  }, 1000);
}

applyTheme('easy');
initGame();
</script>
</body>
</html>
